const org = process.env.STAGE;

module.exports.select = async (pool, organization, table, filter, select, value) => {
    const client = await pool.connect();
    let result;
    try {
        try {
            let selectQuery = `SELECT ${select} FROM ${organization}.${table} ${filter}`
    
            if (org === 'dev') {
                console.log('query ', selectQuery, value !== undefined ? value : '');
            }
            
            value !== undefined ? result = await client.query(selectQuery, value) : result = await client.query(selectQuery)

            org === 'dev' ? console.log('result', result) : ''
        }
        catch (err) {
            result = {
                error: err
            }
        }
    } finally {
        client.release();
    }
    return result;
}

module.exports.insert = async (pool, key, params, value, organization, table, unique, returning) => {
    const client = await pool.connect()

    let response;
    try {
        let insertQuery = `INSERT INTO ${organization}.${table} (${key}) VALUES (${params})`;

        unique !== undefined ? insertQuery += ` ON CONFLICT (${unique}) DO NOTHING` : `;`

        returning !== undefined ? insertQuery += ` RETURNING ${returning}` : '';

        org === 'dev' ? console.log('insertQuery', insertQuery, value) : '';

        response = await client.query(
            insertQuery,
            value
        );

        org === 'dev' ? console.log('response', response) : ''
    }
    catch (err) {
        console.log('err', err)
        response = {
            error: err
        }
    }
    finally {
        client.release()
    }

    return response;
}

module.exports.update = async (pool, key, filter, value, organization, table, returning) => {
    const client = await pool.connect()
    let response;
    try {
        let updateQuery = `UPDATE ${organization}.${table} SET ${key} ${filter}`;
        returning !== undefined ? updateQuery += ` RETURNING ${returning}` : ''

        org === 'dev' ? console.log('updateQuery', updateQuery, value) : '';

        response = await client.query(
            updateQuery,
            value
        );

        org === 'dev' ? console.log('response', response) : ''
    }
    catch (err) {
        console.log('err', err)
        response = {
            error: err
        }
    }
    finally {
        client.release()
    }

    return response;
}

module.exports.delete = async (pool, organization, table, filter, value, returning) => {
    const client = await pool.connect();
    let response;

    try {
        let deleteStatement = `DELETE FROM ${organization}.${table} ${filter}`;

        returning !== undefined ? deleteStatement += ` RETURNING ${returning}` : ''

        if (org === 'dev') {
            console.log('delete query', deleteStatement, value !== undefined ? value : '')
        }
        
        value !== undefined ? response = await client.query(deleteStatement, value) : response = await client.query(deleteStatement);

        org === 'dev' ? console.log('response', response) : ''
    }
    catch (err) {
        console.log('err', err)
        response = {
            error: err
        };
    }
    finally {
        client.release();
    }

    return response;
}

module.exports.insertMuchDatas = async (pool, key, params, value, organization, table, unique, returning) => {
    const client = await pool.connect()
    let response;
    try {
        let insertQuery = `INSERT INTO ${organization}.${table} (${key}) VALUES ${params}`;

        unique !== undefined ? insertQuery += ` ON CONFLICT (${unique}) DO NOTHING;` : `;`

        returning !== undefined ? insertQuery += ` RETURNING ${returning}` : '';
        
        org === 'dev' ? console.log('insertQuery', insertQuery, value) : ''

        response = await client.query(
            insertQuery,
            value
        );

        org === 'dev' ? console.log('response', response) : ''
    }
    catch (err) {
        console.log('err', err)
        response = {
            error: err
        }
    }
    finally {
        client.release()
    }

    return response;
}

module.exports.composeUpdateParams = (tableFields, keyValList, keyParams, updateKeyParams) => { //updateKeyParams optional
    let fields = "";
    let values = [];
    let index = 1;
    let keyParameter = "";

    for (const key in keyValList) {
        if (tableFields.includes(key)) {
            if (keyParams.includes(key)) {
                keyParameter.length > 0 ? keyParameter += " AND " : keyParameter += "WHERE ";

                if (keyValList[key] === null) {
                    keyParameter += key + ' is NULL';
                    continue;
                }

                keyParameter += key + ' = $' + index;                
            }
            else {
                if (fields.length > 0) {
                    fields += ", ";
                }

                fields += key + ' = $' + index;
            }

            values.push(keyValList[key]);

            index++;
        }
    }

    if (updateKeyParams !== undefined && typeof(updateKeyParams) === 'object') {
        for (const key2 in updateKeyParams) {
            if (tableFields.includes(key2)) {
                if (fields.length > 0) {
                    fields += ", ";
                }

                fields += key2 + ' = $' + index;
            }

            values.push(updateKeyParams[key2]);

            index++;
        }
    }
    return { fields: fields, values: values, keyParameter: keyParameter };
}

module.exports.composeInsertParams = (tableFields, keyValList, notUuid) => {
    let fields = "";
    let valuesTemplate = "";
    let values = [];
    let index = 1;

    for (const key in keyValList) {
        if (tableFields.includes(key)) {
            if (fields.length > 0) {
                fields += ", ";
                valuesTemplate += ", ";
            }

            fields += key;

            if (key === 'id' && !notUuid) {
                valuesTemplate += "uuid_generate_v4()";
            }
            else {
                valuesTemplate += "$" + index;
                values.push(keyValList[key]);
                index++;
            }
        }
    }

    return { fields: fields, values: values, valuesTemplate: valuesTemplate }
}